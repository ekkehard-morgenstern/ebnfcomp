
    EBNF Compiler and Parser Generator
    Copyright (C) 2019  Ekkehard Morgenstern

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

    Contact Info:
    E-Mail: ekkehard@ekkehardmorgenstern.de 
    Mail: Ekkehard Morgenstern, Mozartstr. 1, 76744 Woerth am Rhein, Germany, Europe

EBNF Compiler and Parser Generator
----------------------------------

This compiler translates a variant of the Extended Backus-Naur-Form (EBNF) 
(originally developed by Dr. Niklaus Wirth of ETH Zurich university)
into a parser written in one of several languages (currently planned are C and JavaScript).

I added the following features, but otherwise it is very similar to
the original EBNF language as far as I can remember it:
- regular expressions: Now they're simply passed on, and the syntax doesn't attempt to 
  verify or interpret it. This allows for freedom in the choice of generated parser languages.
- new: WHITESPACE and COMMENT production: This allows for easy specification of those.
  When present, the generated parser generator will automatically skip these before parsing 
  any terminal (i.e. token).
- new: TOKEN, TOKEN-ELEMENT and NAMED-TOKEN qualifiers: Allows to explicitly specify which
  production forms a TOKEN, part of a TOKEN or a named token. Named tokens permit to specify
  a production name for symbols that would otherwise go unnamed. This releaves me (or you)
  from providing those in the parser itself.
- new: a mandatory repetitive expression: writing "( expr )+" now signifies a mandatory repetitive
  expression and can be used instead of the form "expr { expr }", which would otherwise have
  to be used.
- new: an error hint: writing '!' after expressions now specifies that this expression must match,
  otherwise the compilation will fail. This is very useful for automated error handling.

Things left to do:
- Currently, there is no way to specify code. Have to find a way to patch in user-defined code.
  For now, the generated parser will only generate a syntax tree from its input, and nothing more.

The syntax of this EBNF, written in itself, is as follows:

WHITESPACE  := /[ \t\n]+/ .
COMMENT     := /--[^\n]+\n/ .

TOKEN identifier  := /[a-z0-9-]+/ .
TOKEN str-literal := /'[^']+'/ | /"[^"]+"/ .

-- during parsing of token elements, whitespace and comment skipping will be disabled
-- regular expressions are not interpreted (anymore) but passed through to the outer layer

TOKEN-ELEMENT re-def-chr     := '\/' | /[^\/]+/ .
TOKEN         re-expr        := '/' ( ( re-def-chr )+ '/' )! .

NAMED-TOKEN   lparen         := '(' .
NAMED-TOKEN   rparen         := ')' .
NAMED-TOKEN   lbracket       := '[' .
NAMED-TOKEN   rbracket       := ']' .
NAMED-TOKEN   lbrace         := '{' .
NAMED-TOKEN   rbrace         := '}' .
NAMED-TOKEN   column         := '|' .
NAMED-TOKEN   dot            := '.' .
NAMED-TOKEN   fail           := '!' .
NAMED-TOKEN   whitespace     := 'WHITESPACE' .
NAMED-TOKEN   comment        := 'COMMENT' .
NAMED-TOKEN   token-element  := 'TOKEN-ELEMENT' .
NAMED-TOKEN   named-token    := 'NAMED-TOKEN' .
NAMED-TOKEN   token          := 'TOKEN' .
NAMED-TOKEN   root           := 'ROOT' .

-- regular productions usually fail silently if they do not match, potentially causing
-- another production in the syntax tree to be tried. to signify failure upon failure to
-- match, '!' can be used in postfix notation.

base-expr   := identifier | str-literal | re-expr | '(' expr ')' [ '+' ] | '[' expr ']' | '{' expr '}' .
fail-expr   := base-expr [ '!' ] .
and-expr    := ( base-expr )+ .
or-expr     := and-expr { '|' and-expr } .
expr        := or-expr .

prod-specifier   := ':=' expr '.' .
whitespace-prod  := ( "WHITESPACE" | "COMMENT" ) ( identifier prod-specifier )! .
prod-qualifier   := "TOKEN-ELEMENT" | "NAMED-TOKEN" | "TOKEN" | "ROOT" .
qualified-prod   := prod-qualifier ( identifier prod-specifier )! .
regular-prod     := identifier prod-specifier! .
production       := whitespace-prod | qualified-prod | regular-prod .
ROOT prod-list   := ( production )+ .
